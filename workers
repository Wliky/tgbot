// Cloudflare Workerï¼šTelegram åŒå‘æœºå™¨äºº + ä¼˜åŒ–ç‰ˆè‡ªåŠ¨ç‚¹èµ + æç®€ä½“éªŒ
// æ ¸å¿ƒä¼˜åŒ–ï¼š
// 1. æ‰€æœ‰è‡ªåŠ¨ç‚¹èµç»Ÿä¸€ä½¿ç”¨ğŸ•Šè¡¨æƒ…ç¬¦å·
// 2. ç¼–è¾‘æ¶ˆæ¯æ—¶å…ˆæ˜¾ç¤ºğŸ¦„ï¼Œ1ç§’åæ”¹ä¸ºğŸ•Š
// 3. ç§»é™¤æ‰€æœ‰è½¬å‘æŒ‰é’®ï¼Œä¿æŒè¯é¢˜åŸç”Ÿä½“éªŒ
// 4. ä»…é¦–æ¬¡åˆ›å»ºè¯é¢˜æ˜¾ç¤ºç”¨æˆ·ä¿¡æ¯ï¼Œæ— ä»»ä½•å†—ä½™æç¤º
// 5. éªŒè¯æç¤ºéšè—åŸå§‹é“¾æ¥ï¼Œç®€åŒ–è¯­è¨€ï¼›éªŒè¯ç•Œé¢ç§»é™¤å¤šä½™æç¤ºï¼›é‡ç½®éªŒè¯ä¸é€šçŸ¥ç”¨æˆ·

export default {
  async fetch(request, env, ctx) {
    try {
      const url = new URL(request.url);
      const path = url.pathname;

      // 1. å¤„ç† Turnstile éªŒè¯
      if (path === "/turnstile-verify") {
        return await handleTurnstileVerify(request, env);
      }

      // 2. å¤„ç† Telegram Webhook
      if (path === "/" && request.method === "POST") {
        return await handleTelegramWebhook(request, env);
      }

      // 3. å¥åº·æ£€æŸ¥
      if (path === "/health" && request.method === "GET") {
        return new Response(JSON.stringify({
          status: "ok",
          timestamp: Date.now(),
          env_check: {
            bot_token: env.BOT_TOKEN ? "é…ç½®å®Œæˆ" : "ç¼ºå¤±",
            supergroup_id: env.SUPERGROUP_ID ? "é…ç½®å®Œæˆ" : "ç¼ºå¤±",
            turnstile: env.TURNSTILE_SITE_KEY && env.TURNSTILE_SECRET_KEY ? "é…ç½®å®Œæˆ" : "ç¼ºå¤±",
            worker_domain: env.WORKER_DOMAIN ? "é…ç½®å®Œæˆ" : "ç¼ºå¤±"
          }
        }), { headers: { "Content-Type": "application/json; charset=utf-8" } });
      }

      return new Response("404 Not Found", { status: 404 });

    } catch (error) {
      console.error("[å…¨å±€é”™è¯¯]", error.stack || error.message);
      return new Response("æœåŠ¡å™¨å†…éƒ¨é”™è¯¯", {
        status: 200,
        headers: { "Content-Type": "text/plain; charset=utf-8" }
      });
    }
  }
};

// ---------------- æ ¸å¿ƒï¼šå¤„ç† Telegram Webhook ----------------
async function handleTelegramWebhook(request, env) {
  try {
    const requestBody = await request.text();
    let update = {};
    
    try {
      update = JSON.parse(requestBody || "{}");
    } catch (e) {
      console.error("[è§£æUpdateå¤±è´¥]", e.message);
      return new Response("OK");
    }

    // å¤„ç†åˆ·æ–°éªŒè¯é“¾æ¥å›è°ƒ
    if (update.callback_query) {
      const query = update.callback_query;
      if (query.data?.startsWith("refresh_verify:")) {
        const userId = query.from.id;
        const oldVerifyId = query.data.split(":")[1];
        
        // æ¸…ç†æ—§éªŒè¯
        await env.TOPIC_MAP.delete(`verify:${oldVerifyId}`);
        // å‘é€æ–°éªŒè¯é“¾æ¥
        await sendVerifyMessage(userId, env);
        // å›å¤å›è°ƒ
        await tgApiCall(env, "answerCallbackQuery", {
          callback_query_id: query.id,
          text: "å·²é‡æ–°ç”ŸæˆéªŒè¯é“¾æ¥ï¼"
        });
        // åˆ é™¤æ—§æ¶ˆæ¯
        await tgApiCall(env, "deleteMessage", {
          chat_id: userId,
          message_id: query.message.message_id
        }).catch(e => console.error("[åˆ é™¤æ—§éªŒè¯æ¶ˆæ¯å¤±è´¥]", e.message));
        
        return new Response("OK");
      }
    }

    // å…¼å®¹æ¶ˆæ¯/ç¼–è¾‘æ¶ˆæ¯
    const msg = update.message || update.edited_message;
    if (!msg || msg.service) return new Response("OK");

    // å¤„ç†è¶…çº§ç¾¤ç»„æ¶ˆæ¯ï¼ˆç®¡ç†å‘˜å›å¤/æŒ‡ä»¤ï¼‰
    if (msg.chat?.type === "supergroup" && msg.message_thread_id) {
      await handleAdminMessage(msg, env);
      return new Response("OK");
    }

    // ä»…å¤„ç†ç§èŠæ¶ˆæ¯
    if (msg.chat?.type !== "private") return new Response("OK");

    // åŸºç¡€ä¿¡æ¯
    const userId = msg.chat.id;
    const userName = msg.from?.first_name || msg.from?.username || "æœªçŸ¥ç”¨æˆ·";
    const userUsername = msg.from?.username ? `@${msg.from.username}` : "æ— ";

    // æ£€æŸ¥é»‘åå•/å…³é—­çŠ¶æ€
    const isBanned = await env.TOPIC_MAP.get(`banned:${userId}`);
    const isClosed = await env.TOPIC_MAP.get(`user_closed:${userId}`);
    
    if (isBanned) return new Response("OK");
    if (isClosed) {
      await tgApiCall(env, "sendMessage", {
        chat_id: userId,
        text: "ğŸš« æ‚¨çš„å¯¹è¯å·²è¢«ç®¡ç†å‘˜å…³é—­",
        parse_mode: "Markdown"
      });
      return new Response("OK");
    }

    // æ£€æŸ¥éªŒè¯çŠ¶æ€
    const isVerified = await env.TOPIC_MAP.get(`verified:${userId}`) === "1";
    
    if (isVerified) {
      // å·²éªŒè¯ï¼šè½¬å‘ç”¨æˆ·æ¶ˆæ¯åˆ°ç¾¤ç»„å¹¶ç‚¹èµ
      await forwardUserMessageToGroup(msg, env, userName, userUsername, !!update.edited_message);
      return new Response("OK");
    }

    // æœªéªŒè¯ï¼šå‘é€éªŒè¯é“¾æ¥ï¼ˆä»…å½“æ— æ´»è·ƒéªŒè¯æ—¶ï¼‰
    const verifyKeys = await env.TOPIC_MAP.list({ prefix: `verify:`, limit: 100 });
    let hasActiveVerify = false;
    
    for (const key of verifyKeys.keys) {
      const verifyData = await env.TOPIC_MAP.get(key.name, { type: "json" }).catch(() => null);
      if (verifyData?.uid === userId.toString()) {
        hasActiveVerify = true;
        break;
      }
    }

    if (!hasActiveVerify) {
      await sendVerifyMessage(userId, env, msg.message_id);
    }

    return new Response("OK");

  } catch (error) {
    console.error("[Webhookå¤„ç†é”™è¯¯]", error.stack || error.message);
    return new Response("OK");
  }
}

// ---------------- å¤„ç†ç®¡ç†å‘˜æ¶ˆæ¯ï¼ˆå›å¤/æŒ‡ä»¤ï¼‰ ----------------
async function handleAdminMessage(msg, env) {
  const threadId = msg.message_thread_id;
  const userId = await getUserIdByTopicId(threadId, env);
  const text = (msg.text || "").trim();

  // æŒ‡ä»¤å¤„ç†
  if (text.startsWith("/")) {
    await handleAdminCommand(text, userId, threadId, env);
    return;
  }

  // æ— ç»‘å®šç”¨æˆ·
  if (!userId) {
    await tgApiCall(env, "sendMessage", {
      chat_id: env.SUPERGROUP_ID,
      message_thread_id: threadId,
      text: "âŒ è¯¥è¯é¢˜æœªç»‘å®šç”¨æˆ·",
      parse_mode: "Markdown"
    });
    return;
  }

  // åˆ¤æ–­æ˜¯å¦ä¸ºç¼–è¾‘æ¶ˆæ¯
  const isEdit = !!msg.edit_date;
  
  // è½¬å‘ç®¡ç†å‘˜å›å¤ç»™ç”¨æˆ·ï¼Œå¹¶ç‚¹èµç®¡ç†å‘˜æ¶ˆæ¯å’Œç”¨æˆ·æ”¶åˆ°çš„æ¶ˆæ¯
  if (msg.media_group_id) {
    // å¤„ç†åª’ä½“ç»„å›å¤
    await handleAdminMediaReply(msg, userId, env, threadId, isEdit);
  } else {
    // å¤„ç†æ™®é€šæ¶ˆæ¯å›å¤
    const copyResult = await tgApiCall(env, "copyMessage", {
      chat_id: userId,
      from_chat_id: env.SUPERGROUP_ID,
      message_id: msg.message_id
    });

    if (copyResult.ok) {
      // 1. ç»™ç®¡ç†å‘˜å‘é€çš„æ¶ˆæ¯ç‚¹èµ
      await setUnifiedReaction(
        env, 
        env.SUPERGROUP_ID, 
        msg.message_id, 
        threadId, 
        isEdit
      );
      
      // 2. ç»™ç”¨æˆ·æ”¶åˆ°çš„å›å¤æ¶ˆæ¯ç‚¹èµ
      await setUnifiedReaction(
        env,
        userId,
        copyResult.result.message_id,
        null, // ç”¨æˆ·ç§èŠæ²¡æœ‰è¯é¢˜ID
        isEdit
      );
    } else {
      console.error(`[è½¬å‘ç®¡ç†å‘˜å›å¤å¤±è´¥] ç”¨æˆ·ID:${userId} é”™è¯¯:${copyResult.description}`);
    }
  }
}

// ---------------- å¤„ç†ç®¡ç†å‘˜æŒ‡ä»¤ ----------------
async function handleAdminCommand(text, userId, threadId, env) {
  // æ— ç»‘å®šç”¨æˆ·æ—¶çš„æŒ‡ä»¤å¤„ç†
  if (!userId && !["/userinfo"].includes(text)) {
    await tgApiCall(env, "sendMessage", {
      chat_id: env.SUPERGROUP_ID,
      message_thread_id: threadId,
      text: "âŒ è¯¥è¯é¢˜æœªç»‘å®šç”¨æˆ·",
      parse_mode: "Markdown"
    });
    return;
  }

  switch (text) {
    case "/userinfo":
      // æŸ¥çœ‹ç”¨æˆ·ä¿¡æ¯
      const userInfo = await tgApiCall(env, "getChat", { chat_id: userId });
      const infoText = userInfo.ok 
        ? `ğŸ“‹ ç”¨æˆ·ä¿¡æ¯\nâ”œâ”€ IDï¼š${userId}\nâ”œâ”€ æ˜µç§°ï¼š${userInfo.result.first_name || "æ— "}\nâ”œâ”€ ç”¨æˆ·åï¼š${userInfo.result.username ? `@${userInfo.result.username}` : "æ— "}\nâ””â”€ éªŒè¯çŠ¶æ€ï¼š${await env.TOPIC_MAP.get(`verified:${userId}`) === "1" ? "âœ… å·²éªŒè¯" : "âŒ æœªéªŒè¯"}`
        : `ğŸ“‹ ç”¨æˆ·IDï¼š${userId}\nâŒ è·å–è¯¦ç»†ä¿¡æ¯å¤±è´¥`;
      
      await tgApiCall(env, "sendMessage", {
        chat_id: env.SUPERGROUP_ID,
        message_thread_id: threadId,
        text: infoText,
        parse_mode: "Markdown"
      });
      break;

    case "/reset_verify":
      // é‡ç½®éªŒè¯çŠ¶æ€ - ä¸é€šçŸ¥ç”¨æˆ·ï¼Œä»…ç®¡ç†å‘˜æ”¶åˆ°æç¤º
      await env.TOPIC_MAP.delete(`verified:${userId}`);
      // æ¸…ç†éªŒè¯é“¾æ¥
      const verifyKeys = await env.TOPIC_MAP.list({ prefix: `verify:`, limit: 100 });
      for (const key of verifyKeys.keys) {
        const verifyData = await env.TOPIC_MAP.get(key.name, { type: "json" }).catch(() => null);
        if (verifyData?.uid === userId.toString()) await env.TOPIC_MAP.delete(key.name);
      }
      // ä»…é€šçŸ¥ç®¡ç†å‘˜ï¼ˆä¸é€šçŸ¥ç”¨æˆ·ï¼‰
      await tgApiCall(env, "sendMessage", {
        chat_id: env.SUPERGROUP_ID,
        message_thread_id: threadId,
        text: `âœ… ç”¨æˆ· ${userId} çš„éªŒè¯çŠ¶æ€å·²é‡ç½®`,
        parse_mode: "Markdown"
      });
      break;

    case "/close":
      // å…³é—­å¯¹è¯
      await env.TOPIC_MAP.put(`user_closed:${userId}`, "1");
      break;

    case "/open":
      // æ‰“å¼€å¯¹è¯
      await env.TOPIC_MAP.delete(`user_closed:${userId}`);
      break;

    case "/ban":
      // å°ç¦ç”¨æˆ·
      await env.TOPIC_MAP.put(`banned:${userId}`, "1");
      break;

    case "/unban":
      // è§£å°ç”¨æˆ·
      await env.TOPIC_MAP.delete(`banned:${userId}`);
      break;

    default:
      // å¤„ç†æœ‰æ•ˆæœŸè®¾ç½®
      if (text.startsWith("/verify_ttl")) {
        const parts = text.split(" ");
        if (parts.length < 2) {
          await tgApiCall(env, "sendMessage", {
            chat_id: env.SUPERGROUP_ID,
            message_thread_id: threadId,
            text: "âŒ æ ¼å¼ï¼š/verify_ttl 7d/30d/1y/æ°¸ä¹…",
            parse_mode: "Markdown"
          });
          return;
        }

        const ttlMap = { "7d": 604800, "30d": 2592000, "1y": 31536000, "æ°¸ä¹…": 0 };
        const ttl = ttlMap[parts[1].toLowerCase()];
        
        if (ttl === undefined) {
          await tgApiCall(env, "sendMessage", {
            chat_id: env.SUPERGROUP_ID,
            message_thread_id: threadId,
            text: "âŒ æ”¯æŒï¼š7d/30d/1y/æ°¸ä¹…",
            parse_mode: "Markdown"
          });
          return;
        }

        if (ttl > 0) {
          await env.TOPIC_MAP.put(`verified:${userId}`, "1", { expirationTtl: ttl });
        } else {
          await env.TOPIC_MAP.put(`verified:${userId}`, "1");
        }

        // ä»…é€šçŸ¥ç®¡ç†å‘˜
        await tgApiCall(env, "sendMessage", {
          chat_id: env.SUPERGROUP_ID,
          message_thread_id: threadId,
          text: `âœ… ç”¨æˆ· ${userId} çš„éªŒè¯æœ‰æ•ˆæœŸå·²è®¾ç½®ä¸ºï¼š${parts[1]}`,
          parse_mode: "Markdown"
        });
      }
      break;
  }
}

// ---------------- è½¬å‘ç”¨æˆ·æ¶ˆæ¯åˆ°ç¾¤ç»„ï¼ˆæ ¸å¿ƒï¼šç‚¹èµç”¨æˆ·æ¶ˆæ¯ï¼‰ ----------------
async function forwardUserMessageToGroup(msg, env, userName, userUsername, isEdit = false) {
  try {
    const userId = msg.from.id;
    // è·å–/åˆ›å»ºè¯é¢˜IDï¼ˆä»…é¦–æ¬¡æ˜¾ç¤ºç”¨æˆ·ä¿¡æ¯ï¼‰
    const topicId = await getOrCreateTopicId(userId, env, userName, userUsername);

    if (msg.media_group_id) {
      // å¤„ç†åª’ä½“ç»„æ¶ˆæ¯
      await handleUserMediaGroup(msg, env, topicId, isEdit);
    } else {
      // è½¬å‘æ™®é€šæ¶ˆæ¯
      const forwardResult = await tgApiCall(env, "forwardMessage", {
        chat_id: env.SUPERGROUP_ID,
        from_chat_id: msg.chat.id,
        message_id: msg.message_id,
        message_thread_id: topicId
      });

      if (forwardResult.ok) {
        // 1. ç»™ç¾¤ç»„ä¸­çš„æ¶ˆæ¯ç‚¹èµ
        await setUnifiedReaction(
          env,
          env.SUPERGROUP_ID,
          forwardResult.result.message_id,
          topicId,
          isEdit
        );
        
        // 2. ç»™ç”¨æˆ·çš„åŸå§‹æ¶ˆæ¯ç‚¹èµ
        await setUnifiedReaction(
          env,
          msg.chat.id,
          msg.message_id,
          null, // ç”¨æˆ·ç§èŠæ²¡æœ‰è¯é¢˜ID
          isEdit
        );
      } else {
        // é™çº§å¤åˆ¶æ¶ˆæ¯
        const copyResult = await tgApiCall(env, "copyMessage", {
          chat_id: env.SUPERGROUP_ID,
          from_chat_id: msg.chat.id,
          message_id: msg.message_id,
          message_thread_id: topicId
        });

        if (copyResult.ok) {
          // 1. ç»™ç¾¤ç»„ä¸­çš„æ¶ˆæ¯ç‚¹èµ
          await setUnifiedReaction(
            env,
            env.SUPERGROUP_ID,
            copyResult.result.message_id,
            topicId,
            isEdit
          );
          
          // 2. ç»™ç”¨æˆ·çš„åŸå§‹æ¶ˆæ¯ç‚¹èµ
          await setUnifiedReaction(
            env,
            msg.chat.id,
            msg.message_id,
            null, // ç”¨æˆ·ç§èŠæ²¡æœ‰è¯é¢˜ID
            isEdit
          );
        }
      }
    }
  } catch (error) {
    console.error("[è½¬å‘ç”¨æˆ·æ¶ˆæ¯å¤±è´¥]", error.message);
    await tgApiCall(env, "sendMessage", {
      chat_id: msg.chat.id,
      text: "ğŸš« æ¶ˆæ¯å‘é€å¤±è´¥",
      parse_mode: "Markdown"
    }).catch(() => {});
  }
}

// ---------------- æ ¸å¿ƒï¼šç»Ÿä¸€çš„è¡¨æƒ…è®¾ç½®å‡½æ•° ----------------
async function setUnifiedReaction(env, chatId, messageId, threadId = null, isEdit = false, maxRetries = 3) {
  try {
    const reactionParams = {
      chat_id: chatId,
      message_id: messageId,
      reaction: [{ type: "emoji", emoji: isEdit ? "ğŸ¦„" : "ğŸ•Š" }]
    };
    
    // å¦‚æœæœ‰è¯é¢˜IDï¼Œæ·»åŠ å‚æ•°
    if (threadId !== null) {
      reactionParams.message_thread_id = threadId;
    }
    
    // è®¾ç½®åˆå§‹è¡¨æƒ…
    for (let i = 0; i < maxRetries; i++) {
      try {
        await tgApiCall(env, "setMessageReaction", reactionParams);
        break;
      } catch (error) {
        if (i === maxRetries - 1) {
          console.error(`[è®¾ç½®ååº”å¤±è´¥] é‡è¯• ${i + 1}æ¬¡å¤±è´¥:`, error.message);
        } else {
          await new Promise(resolve => setTimeout(resolve, 500 * (i + 1)));
        }
      }
    }
    
    // å¦‚æœæ˜¯ç¼–è¾‘æ¶ˆæ¯ï¼Œ1ç§’åæ”¹ä¸ºğŸ•Š
    if (isEdit) {
      setTimeout(async () => {
        reactionParams.reaction = [{ type: "emoji", emoji: "ğŸ•Š" }];
        for (let i = 0; i < maxRetries; i++) {
          try {
            await tgApiCall(env, "setMessageReaction", reactionParams);
            break;
          } catch (error) {
            if (i === maxRetries - 1) {
              console.error(`[ç¼–è¾‘åæ”¹å›é¸½å­å¤±è´¥] é‡è¯• ${i + 1}æ¬¡å¤±è´¥:`, error.message);
            } else {
              await new Promise(resolve => setTimeout(resolve, 500 * (i + 1)));
            }
          }
        }
      }, 1000);
    }
  } catch (error) {
    console.error("[ç»Ÿä¸€ç‚¹èµå¤±è´¥]", error.message);
  }
}

// ---------------- å¤„ç†ç®¡ç†å‘˜åª’ä½“ç»„å›å¤ ----------------
async function handleAdminMediaReply(msg, userId, env, threadId, isEdit = false) {
  const groupId = msg.media_group_id;
  const cacheKey = `admin_media:${groupId}`;
  
  let mediaGroup = await env.TOPIC_MAP.get(cacheKey, { type: "json" }).catch(() => null) || { items: [] };

  // æå–åª’ä½“ä¿¡æ¯
  let mediaItem = null;
  if (msg.photo) mediaItem = { type: "photo", media: msg.photo.pop().file_id, caption: msg.caption };
  if (msg.video) mediaItem = { type: "video", media: msg.video.file_id, caption: msg.caption };
  if (msg.document) mediaItem = { type: "document", media: msg.document.file_id, caption: msg.caption };

  if (mediaItem) {
    mediaGroup.items.push(mediaItem);
    await env.TOPIC_MAP.put(cacheKey, JSON.stringify(mediaGroup), { expirationTtl: 60 });

    // å»¶è¿Ÿå‘é€ï¼ˆç­‰å¾…æ‰€æœ‰åª’ä½“åˆ†ç‰‡ï¼‰
    setTimeout(async () => {
      const latestMedia = await env.TOPIC_MAP.get(cacheKey, { type: "json" }).catch(() => null);
      if (latestMedia?.items.length) {
        const sendResult = await tgApiCall(env, "sendMediaGroup", {
          chat_id: userId,
          media: latestMedia.items.map(item => ({
            type: item.type,
            media: item.media,
            caption: item.caption || ""
          }))
        });

        if (sendResult.ok) {
          // 1. ç‚¹èµç®¡ç†å‘˜çš„åª’ä½“ç»„æ¶ˆæ¯
          await setUnifiedReaction(env, env.SUPERGROUP_ID, msg.message_id, threadId, isEdit);
          
          // 2. ç‚¹èµç”¨æˆ·æ”¶åˆ°çš„åª’ä½“ç»„æ¶ˆæ¯
          for (const msgItem of sendResult.result) {
            await setUnifiedReaction(env, userId, msgItem.message_id, null, isEdit);
          }
        }

        await env.TOPIC_MAP.delete(cacheKey);
      }
    }, 2000);
  }
}

// ---------------- å¤„ç†ç”¨æˆ·åª’ä½“ç»„æ¶ˆæ¯ ----------------
async function handleUserMediaGroup(msg, env, topicId, isEdit = false) {
  const groupId = msg.media_group_id;
  const cacheKey = `user_media:${groupId}`;
  
  let mediaGroup = await env.TOPIC_MAP.get(cacheKey, { type: "json" }).catch(() => null) || { items: [] };

  // æå–åª’ä½“ä¿¡æ¯
  let mediaItem = null;
  if (msg.photo) mediaItem = { type: "photo", media: msg.photo.pop().file_id, caption: msg.caption };
  if (msg.video) mediaItem = { type: "video", media: msg.video.file_id, caption: msg.caption };
  if (msg.document) mediaItem = { type: "document", media: msg.document.file_id, caption: msg.caption };

  if (mediaItem) {
    mediaGroup.items.push(mediaItem);
    await env.TOPIC_MAP.put(cacheKey, JSON.stringify(mediaGroup), { expirationTtl: 60 });

    // å»¶è¿Ÿå‘é€
    setTimeout(async () => {
      const latestMedia = await env.TOPIC_MAP.get(cacheKey, { type: "json" }).catch(() => null);
      if (latestMedia?.items.length) {
        const sendResult = await tgApiCall(env, "sendMediaGroup", {
          chat_id: env.SUPERGROUP_ID,
          media: latestMedia.items.map(item => ({
            type: item.type,
            media: item.media,
            caption: item.caption || ""
          })),
          message_thread_id: topicId
        });

        if (sendResult.ok) {
          // 1. ç‚¹èµç”¨æˆ·åŸå§‹æ¶ˆæ¯ï¼ˆæ¯æ¡åª’ä½“ç»„æ¶ˆæ¯å¯¹åº”ä¸€ä¸ªç‚¹èµï¼‰
          await setUnifiedReaction(env, msg.chat.id, msg.message_id, null, isEdit);
          
          // 2. ç‚¹èµæ¯æ¡åª’ä½“æ¶ˆæ¯ï¼ˆä½¿ç”¨ğŸ•Šï¼‰
          for (const msgItem of sendResult.result) {
            await setUnifiedReaction(env, env.SUPERGROUP_ID, msgItem.message_id, topicId, isEdit);
          }
        }

        await env.TOPIC_MAP.delete(cacheKey);
      }
    }, 2000);
  }
}

// ---------------- è·å–/åˆ›å»ºè¯é¢˜IDï¼ˆä»…é¦–æ¬¡æ˜¾ç¤ºç”¨æˆ·ä¿¡æ¯ï¼‰ ----------------
async function getOrCreateTopicId(userId, env, userName, userUsername) {
  const topicKey = `user_topic:${userId}`;
  let topicId = await env.TOPIC_MAP.get(topicKey).catch(() => null);

  if (topicId) return Number(topicId);

  // é¦–æ¬¡åˆ›å»ºè¯é¢˜
  userName = userName || (await getUserName(userId, env));
  const createResult = await tgApiCall(env, "createForumTopic", {
    chat_id: env.SUPERGROUP_ID,
    name: `ç”¨æˆ· ${userName} (ID: ${userId})`
  });

  if (createResult.ok) {
    topicId = createResult.result.message_thread_id;
    await env.TOPIC_MAP.put(topicKey, topicId.toString());

    // ä»…é¦–æ¬¡æ˜¾ç¤ºç”¨æˆ·ä¿¡æ¯
    await tgApiCall(env, "sendMessage", {
      chat_id: env.SUPERGROUP_ID,
      message_thread_id: topicId,
      text: `ğŸ“‹ ç”¨æˆ·ä¿¡æ¯\nâ”œâ”€ ç”¨æˆ·åï¼š${userName}\nâ”œâ”€ è´¦å·ï¼š${userUsername || "æ— "}\nâ””â”€ ç”¨æˆ·IDï¼š${userId}`,
      parse_mode: "Markdown"
    });

    return topicId;
  }

  return 0;
}

// ---------------- è¾…åŠ©å‡½æ•° ----------------
async function sendVerifyMessage(userId, env, msgId = null) {
  // æ¸…ç†æ—§éªŒè¯é“¾æ¥
  const verifyKeys = await env.TOPIC_MAP.list({ prefix: `verify:`, limit: 100 });
  for (const key of verifyKeys.keys) {
    const verifyData = await env.TOPIC_MAP.get(key.name, { type: "json" }).catch(() => null);
    if (verifyData?.uid === userId.toString()) await env.TOPIC_MAP.delete(key.name);
  }

  // ç”Ÿæˆæ–°éªŒè¯é“¾æ¥
  const verifyId = Math.random().toString(36).slice(2, 15);
  await env.TOPIC_MAP.put(
    `verify:${verifyId}`,
    JSON.stringify({ uid: userId.toString(), msgId }),
    { expirationTtl: 300 }
  );

  const verifyUrl = `https://${env.WORKER_DOMAIN}/turnstile-verify?vid=${verifyId}&uid=${userId}`;
  
  // ä¼˜åŒ–ï¼šç®€åŒ–å®‰å…¨éªŒè¯æç¤ºè¯­è¨€ï¼Œéšè—åŸå§‹é“¾æ¥
  await tgApiCall(env, "sendMessage", {
    chat_id: userId,
    text: `ğŸ›¡ï¸ å®‰å…¨éªŒè¯\n\nè¯·å®ŒæˆäººæœºéªŒè¯åå‘é€æ¶ˆæ¯ï¼š`,
    parse_mode: "Markdown",
    disable_web_page_preview: true,
    reply_markup: {
      inline_keyboard: [
        [{ text: "âœ… ç‚¹å‡»éªŒè¯", url: verifyUrl }],
        [{ text: "ğŸ”„ é‡æ–°è·å–é“¾æ¥", callback_data: `refresh_verify:${verifyId}` }]
      ]
    }
  });
}

async function getUserIdByTopicId(threadId, env) {
  const list = await env.TOPIC_MAP.list({ prefix: "user_topic:" });
  for (const key of list.keys) {
    const storedTopicId = await env.TOPIC_MAP.get(key.name).catch(() => null);
    if (storedTopicId?.toString() === threadId.toString()) {
      return Number(key.name.replace("user_topic:", ""));
    }
  }
  return null;
}

async function getUserName(userId, env) {
  const res = await tgApiCall(env, "getChat", { chat_id: userId });
  return res.ok ? (res.result.first_name || res.result.username || "æœªçŸ¥ç”¨æˆ·") : "æœªçŸ¥ç”¨æˆ·";
}

async function handleTurnstileVerify(request, env) {
  const url = new URL(request.url);
  const verifyId = url.searchParams.get("vid");
  const userId = url.searchParams.get("uid");

  if (!verifyId || !userId || isNaN(Number(userId))) {
    // ä¼˜åŒ–ï¼šè¿”å›ç¾è§‚çš„æ— æ•ˆé“¾æ¥é¡µé¢
    return new Response(generateExpiredPage("æ— æ•ˆçš„éªŒè¯é“¾æ¥", "é“¾æ¥å‚æ•°é”™è¯¯"), {
      status: 400,
      headers: {
        "Content-Type": "text/html; charset=utf-8",
        "Cache-Control": "no-cache"
      }
    });
  }

  // GETï¼šè¿”å›éªŒè¯é¡µé¢
  if (request.method === "GET") {
    const verifyState = await env.TOPIC_MAP.get(`verify:${verifyId}`);
    if (!verifyState) {
      // ä¼˜åŒ–ï¼šè¿”å›ç¾è§‚çš„è¿‡æœŸé¡µé¢
      return new Response(generateExpiredPage("éªŒè¯é“¾æ¥å·²è¿‡æœŸ", "è¯·é‡æ–°å‘é€æ¶ˆæ¯è·å–æ–°é“¾æ¥"), {
        status: 400,
        headers: {
          "Content-Type": "text/html; charset=utf-8",
          "Cache-Control": "no-cache"
        }
      });
    }

    const html = generateVerifyPage(env.TURNSTILE_SITE_KEY, verifyId, userId);
    return new Response(html, {
      headers: {
        "Content-Type": "text/html; charset=utf-8",
        "Cache-Control": "no-cache"
      }
    });
  }

  // POSTï¼šå¤„ç†éªŒè¯æäº¤
  if (request.method === "POST") {
    try {
      const { token } = await request.json();
      
      // éªŒè¯Turnstile
      const turnstileRes = await fetch("https://challenges.cloudflare.com/turnstile/v0/siteverify", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          secret: env.TURNSTILE_SECRET_KEY,
          response: token,
          remoteip: request.headers.get("CF-Connecting-IP")
        })
      });

      const turnstileData = await turnstileRes.json();
      if (!turnstileData.success) {
        return new Response(JSON.stringify({
          success: false,
          error: turnstileData["error-codes"]?.join(", ") || "éªŒè¯å¤±è´¥"
        }), { headers: { "Content-Type": "application/json" } });
      }

      // éªŒè¯æˆåŠŸ
      await env.TOPIC_MAP.put(`verified:${userId}`, "1", { expirationTtl: 604800 });
      
      // æ¸…ç†éªŒè¯é“¾æ¥
      const verifyKeys = await env.TOPIC_MAP.list({ prefix: `verify:`, limit: 100 });
      for (const key of verifyKeys.keys) {
        const verifyData = await env.TOPIC_MAP.get(key.name, { type: "json" }).catch(() => null);
        if (verifyData?.uid === userId.toString()) await env.TOPIC_MAP.delete(key.name);
      }

      // è½¬å‘å¾…å‘é€æ¶ˆæ¯
      const verifyState = await env.TOPIC_MAP.get(`verify:${verifyId}`, { type: "json" }).catch(() => null);
      if (verifyState?.msgId) {
        const msgRes = await tgApiCall(env, "getMessage", {
          chat_id: userId,
          message_id: verifyState.msgId
        });
        
        if (msgRes.ok) {
          const userName = msgRes.result.from.first_name || msgRes.result.from.username || "æœªçŸ¥ç”¨æˆ·";
          const userUsername = msgRes.result.from.username ? `@${msgRes.result.from.username}` : "æ— ";
          await forwardUserMessageToGroup(msgRes.result, env, userName, userUsername);
        }
      }

      // é€šçŸ¥ç”¨æˆ·
      await tgApiCall(env, "sendMessage", {
        chat_id: userId,
        text: "âœ… éªŒè¯æˆåŠŸï¼",
        parse_mode: "Markdown"
      });

      return new Response(JSON.stringify({
        success: true,
        message: "éªŒè¯æˆåŠŸ"
      }), { headers: { "Content-Type": "application/json" } });

    } catch (error) {
      return new Response(JSON.stringify({
        success: false,
        error: error.message
      }), { headers: { "Content-Type": "application/json" } });
    }
  }

  return new Response("ä¸æ”¯æŒçš„è¯·æ±‚æ–¹æ³•", { status: 405 });
}

// ---------------- ç”Ÿæˆç¾è§‚çš„è¿‡æœŸ/æ— æ•ˆé“¾æ¥é¡µé¢ ----------------
function generateExpiredPage(title, description) {
  return `
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${title} - å®‰å…¨éªŒè¯</title>
  <style>
    :root {
      --bg-color: #ffffff;
      --text-color: #333333;
      --card-bg: #f8f9fa;
      --border-color: #e0e0e0;
      --error-color: #dc3545;
      --primary-color: #0088cc;
      --shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --bg-color: #1a1a1a;
        --text-color: #f0f0f0;
        --card-bg: #2d2d2d;
        --border-color: #404040;
        --error-color: #ff3b30;
        --primary-color: #3399ff;
        --shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      }
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
      line-height: 1.6;
      min-height: 100vh;
      padding: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .container {
      max-width: 500px;
      width: 100%;
      margin: 0 auto;
    }

    .card {
      background-color: var(--card-bg);
      border-radius: 20px;
      padding: 40px 32px;
      box-shadow: var(--shadow);
      border: 1px solid var(--border-color);
      text-align: center;
    }

    .icon {
      font-size: 64px;
      color: var(--error-color);
      margin-bottom: 24px;
      display: inline-block;
    }

    .title {
      font-size: 28px;
      font-weight: 600;
      margin-bottom: 16px;
      color: var(--text-color);
    }

    .description {
      font-size: 16px;
      color: var(--text-color);
      opacity: 0.8;
      margin-bottom: 32px;
      line-height: 1.8;
    }

    .action-btn {
      display: inline-block;
      padding: 14px 32px;
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 500;
      text-decoration: none;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .action-btn:hover {
      background-color: #006699;
      transform: translateY(-2px);
      box-shadow: 0 8px 15px rgba(0, 136, 204, 0.2);
    }

    .action-btn:active {
      transform: translateY(0);
    }

    @media (max-width: 600px) {
      body {
        padding: 16px;
      }
      
      .card {
        padding: 32px 24px;
      }
      
      .title {
        font-size: 24px;
      }
      
      .description {
        font-size: 14px;
      }
      
      .action-btn {
        padding: 12px 24px;
        font-size: 15px;
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="card">
      <div class="icon">ğŸ”’</div>
      <h1 class="title">${title}</h1>
      <p class="description">${description}</p>
      <a href="javascript:window.close()" class="action-btn">å…³é—­çª—å£</a>
    </div>
  </div>
</body>
</html>
  `;
}

// ---------------- ç”Ÿæˆç®€åŒ–ç‰ˆéªŒè¯é¡µé¢ï¼ˆç§»é™¤å¤šä½™æç¤ºï¼Œä¿®å¤æŒ‰é’®é—®é¢˜ï¼‰ ----------------
function generateVerifyPage(siteKey, verifyId, userId) {
  return `
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>å®‰å…¨éªŒè¯</title>
  <script src="https://challenges.cloudflare.com/turnstile/v0/api.js?render=explicit"></script>
  <style>
    :root {
      --bg-color: #ffffff;
      --text-color: #333333;
      --card-bg: #f8f9fa;
      --border-color: #e0e0e0;
      --primary-color: #0088cc;
      --primary-hover: #006699;
      --success-color: #28a745;
      --error-color: #dc3545;
      --shadow: 0 8px 30px rgba(0, 0, 0, 0.1);
      --gradient: linear-gradient(135deg, #0088cc 0%, #00a8e8 100%);
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --bg-color: #121212;
        --text-color: #f5f5f5;
        --card-bg: #1e1e1e;
        --border-color: #333333;
        --primary-color: #3399ff;
        --primary-hover: #66b3ff;
        --success-color: #34c759;
        --error-color: #ff3b30;
        --shadow: 0 8px 30px rgba(0, 0, 0, 0.3);
        --gradient: linear-gradient(135deg, #3399ff 0%, #0066cc 100%);
      }
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      transition: all 0.3s ease;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
      line-height: 1.6;
      min-height: 100vh;
      padding: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .container {
      max-width: 520px;
      width: 100%;
      margin: 0 auto;
    }

    .card {
      background-color: var(--card-bg);
      border-radius: 24px;
      padding: 40px 32px;
      box-shadow: var(--shadow);
      border: 1px solid var(--border-color);
      position: relative;
      overflow: hidden;
    }

    .card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: var(--gradient);
    }

    .header {
      text-align: center;
      margin-bottom: 32px;
    }

    .icon-wrapper {
      width: 80px;
      height: 80px;
      background: var(--gradient);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto 20px;
      box-shadow: 0 4px 15px rgba(0, 136, 204, 0.2);
    }

    .icon {
      font-size: 40px;
      color: white;
    }

    .title {
      font-size: 28px;
      font-weight: 700;
      margin-bottom: 8px;
      color: var(--text-color);
    }

    .subtitle {
      font-size: 16px;
      color: var(--text-color);
      opacity: 0.8;
    }

    .turnstile-container {
      display: flex;
      justify-content: center;
      margin: 30px 0;
      min-height: 70px;
      padding: 10px;
      border-radius: 12px;
      background-color: rgba(0, 0, 0, 0.02);
      border: 1px solid var(--border-color);
    }

    /* ä¿®å¤æŒ‰é’®æ˜¾ç¤ºé—®é¢˜ - æ ¸å¿ƒä¼˜åŒ– */
    #verify-btn {
      width: 100%;
      padding: 16px 24px;
      background: var(--gradient);
      color: white;
      border: none;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      box-shadow: 0 4px 15px rgba(0, 136, 204, 0.15);
      position: relative;
      overflow: hidden;
      z-index: 1;
    }

    #verify-btn::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: 0.5s;
      z-index: -1;
    }

    #verify-btn:hover:not(:disabled)::after {
      left: 100%;
    }

    #verify-btn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(0, 136, 204, 0.25);
    }

    #verify-btn:active:not(:disabled) {
      transform: translateY(0);
      box-shadow: 0 4px 10px rgba(0, 136, 204, 0.2);
    }

    #verify-btn:disabled {
      opacity: 0.7;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    #verify-btn i {
      font-size: 20px;
    }

    .message-box {
      padding: 16px;
      border-radius: 12px;
      margin: 20px 0;
      display: none;
      border-left: 4px solid;
    }

    .error-message {
      background-color: rgba(220, 53, 69, 0.08);
      color: var(--error-color);
      border-color: var(--error-color);
    }

    .success-message {
      background-color: rgba(40, 167, 69, 0.08);
      color: var(--success-color);
      border-color: var(--success-color);
    }

    .loading {
      display: none;
      justify-content: center;
      margin: 15px 0;
    }

    .loading-spinner {
      width: 24px;
      height: 24px;
      border: 3px solid rgba(0, 136, 204, 0.2);
      border-top-color: var(--primary-color);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    @media (max-width: 600px) {
      body {
        padding: 16px;
      }
      
      .card {
        padding: 32px 24px;
      }
      
      .title {
        font-size: 24px;
      }
      
      .subtitle {
        font-size: 14px;
      }
      
      .icon-wrapper {
        width: 70px;
        height: 70px;
      }
      
      .icon {
        font-size: 36px;
      }
      
      #verify-btn {
        padding: 14px 20px;
        font-size: 15px;
      }
    }

    @media (max-width: 400px) {
      .card {
        padding: 24px 16px;
      }
      
      .icon-wrapper {
        width: 60px;
        height: 60px;
      }
      
      .icon {
        font-size: 32px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="card">
      <div class="header">
        <div class="icon-wrapper">
          <div class="icon">ğŸ›¡ï¸</div>
        </div>
        <h1 class="title">å®‰å…¨éªŒè¯</h1>
        <p class="subtitle">å®ŒæˆéªŒè¯å³å¯å‘é€æ¶ˆæ¯</p>
      </div>

      <div id="turnstile-widget" class="turnstile-container"></div>

      <div id="error" class="message-box error-message"></div>
      <div id="success" class="message-box success-message"></div>

      <div class="loading" id="loading">
        <div class="loading-spinner"></div>
      </div>

      <button id="verify-btn" disabled>
        <i>âœ…</i>
        <span>å®ŒæˆéªŒè¯</span>
      </button>
    </div>
  </div>

  <script>
    let token = "";
    let widgetId = null;
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
    
    // åˆå§‹åŒ– Turnstile
    window.onload = function() {
      initTurnstile();
      // ç»‘å®šæŒ‰é’®ç‚¹å‡»äº‹ä»¶ï¼ˆä¿®å¤æŒ‰é’®ç‚¹å‡»é—®é¢˜ï¼‰
      document.getElementById('verify-btn').addEventListener('click', submitVerify);
    };

    // åˆå§‹åŒ–Turnstile
    function initTurnstile() {
      if (window.turnstile) {
        if (widgetId) window.turnstile.remove(widgetId);
        
        widgetId = window.turnstile.render('#turnstile-widget', {
          sitekey: "${siteKey}",
          theme: isDarkMode ? 'dark' : 'light',
          size: 'normal',
          callback: function(t) {
            token = t;
            const btn = document.getElementById('verify-btn');
            btn.disabled = false;
            btn.innerHTML = '<i>âœ…</i><span>å®ŒæˆéªŒè¯</span>';
            document.getElementById('error').style.display = 'none';
          },
          'error-callback': function(error) {
            const errorEl = document.getElementById('error');
            errorEl.style.display = 'block';
            errorEl.textContent = 'éªŒè¯åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•';
          }
        });
      }
    }

    // ç›‘å¬ä¸»é¢˜å˜åŒ–
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', function(e) {
      initTurnstile();
    });

    // éªŒè¯æäº¤å‡½æ•°
    async function submitVerify() {
      if (!token) return;
      
      const btn = document.getElementById('verify-btn');
      const errorEl = document.getElementById('error');
      const successEl = document.getElementById('success');
      const loadingEl = document.getElementById('loading');
      
      errorEl.style.display = 'none';
      successEl.style.display = 'none';
      btn.disabled = true;
      loadingEl.style.display = 'flex';
      btn.innerHTML = '<i>â³</i><span>éªŒè¯ä¸­...</span>';
      
      try {
        const res = await fetch(window.location.href, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ token })
        });
        
        const data = await res.json();
        
        if (data.success) {
          successEl.style.display = 'block';
          successEl.textContent = 'âœ… éªŒè¯æˆåŠŸï¼çª—å£å°†è‡ªåŠ¨å…³é—­';
          btn.style.display = 'none';
          loadingEl.style.display = 'none';
          
          setTimeout(() => window.close(), 2000);
        } else {
          errorEl.style.display = 'block';
          errorEl.textContent = 'âŒ éªŒè¯å¤±è´¥ï¼š' + (data.error || 'è¯·é‡è¯•');
          btn.disabled = false;
          loadingEl.style.display = 'none';
          btn.innerHTML = '<i>ğŸ”„</i><span>é‡æ–°éªŒè¯</span>';
          
          initTurnstile();
          token = "";
        }
      } catch (e) {
        errorEl.style.display = 'block';
        errorEl.textContent = 'âŒ ç½‘ç»œé”™è¯¯ï¼š' + e.message;
        btn.disabled = false;
        loadingEl.style.display = 'none';
        btn.innerHTML = '<i>ğŸ”—</i><span>é‡æ–°éªŒè¯</span>';
        
        initTurnstile();
        token = "";
      }
    }

    // é”®ç›˜å›è½¦æäº¤
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Enter' && !document.getElementById('verify-btn').disabled) {
        submitVerify();
      }
    });
  </script>
</body>
</html>
  `;
}

async function tgApiCall(env, method, body) {
  try {
    const controller = new AbortController();
    setTimeout(() => controller.abort(), 10000);

    const res = await fetch(`https://api.telegram.org/bot${env.BOT_TOKEN}/${method}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
      signal: controller.signal
    });

    const result = await res.json();
    if (!result.ok) console.error(`[TG APIå¤±è´¥] ${method}: ${result.description}`);
    return result;
  } catch (error) {
    console.error(`[TG APIè°ƒç”¨å¤±è´¥] ${method}: ${error.message}`);
    return { ok: false, description: error.message };
  }
}
